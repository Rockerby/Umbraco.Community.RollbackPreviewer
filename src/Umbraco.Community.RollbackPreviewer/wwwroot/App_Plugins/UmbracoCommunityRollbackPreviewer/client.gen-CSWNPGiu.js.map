{"version":3,"file":"client.gen-CSWNPGiu.js","sources":["../../../Client/src/api/core/bodySerializer.gen.ts","../../../Client/src/api/core/serverSentEvents.gen.ts","../../../Client/src/api/core/pathSerializer.gen.ts","../../../Client/src/api/core/utils.gen.ts","../../../Client/src/api/core/auth.gen.ts","../../../Client/src/api/client/utils.gen.ts","../../../Client/src/api/client/client.gen.ts","../../../Client/src/api/client.gen.ts"],"sourcesContent":["// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type {\r\n  ArrayStyle,\r\n  ObjectStyle,\r\n  SerializerOptions,\r\n} from './pathSerializer.gen';\r\n\r\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\r\n\r\nexport type BodySerializer = (body: any) => any;\r\n\r\nexport interface QuerySerializerOptions {\r\n  allowReserved?: boolean;\r\n  array?: SerializerOptions<ArrayStyle>;\r\n  object?: SerializerOptions<ObjectStyle>;\r\n}\r\n\r\nconst serializeFormDataPair = (\r\n  data: FormData,\r\n  key: string,\r\n  value: unknown,\r\n): void => {\r\n  if (typeof value === 'string' || value instanceof Blob) {\r\n    data.append(key, value);\r\n  } else if (value instanceof Date) {\r\n    data.append(key, value.toISOString());\r\n  } else {\r\n    data.append(key, JSON.stringify(value));\r\n  }\r\n};\r\n\r\nconst serializeUrlSearchParamsPair = (\r\n  data: URLSearchParams,\r\n  key: string,\r\n  value: unknown,\r\n): void => {\r\n  if (typeof value === 'string') {\r\n    data.append(key, value);\r\n  } else {\r\n    data.append(key, JSON.stringify(value));\r\n  }\r\n};\r\n\r\nexport const formDataBodySerializer = {\r\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\r\n    body: T,\r\n  ): FormData => {\r\n    const data = new FormData();\r\n\r\n    Object.entries(body).forEach(([key, value]) => {\r\n      if (value === undefined || value === null) {\r\n        return;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        value.forEach((v) => serializeFormDataPair(data, key, v));\r\n      } else {\r\n        serializeFormDataPair(data, key, value);\r\n      }\r\n    });\r\n\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const jsonBodySerializer = {\r\n  bodySerializer: <T>(body: T): string =>\r\n    JSON.stringify(body, (_key, value) =>\r\n      typeof value === 'bigint' ? value.toString() : value,\r\n    ),\r\n};\r\n\r\nexport const urlSearchParamsBodySerializer = {\r\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\r\n    body: T,\r\n  ): string => {\r\n    const data = new URLSearchParams();\r\n\r\n    Object.entries(body).forEach(([key, value]) => {\r\n      if (value === undefined || value === null) {\r\n        return;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\r\n      } else {\r\n        serializeUrlSearchParamsPair(data, key, value);\r\n      }\r\n    });\r\n\r\n    return data.toString();\r\n  },\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { Config } from './types.gen';\r\n\r\nexport type ServerSentEventsOptions<TData = unknown> = Omit<\r\n  RequestInit,\r\n  'method'\r\n> &\r\n  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {\r\n    /**\r\n     * Fetch API implementation. You can use this option to provide a custom\r\n     * fetch instance.\r\n     *\r\n     * @default globalThis.fetch\r\n     */\r\n    fetch?: typeof fetch;\r\n    /**\r\n     * Implementing clients can call request interceptors inside this hook.\r\n     */\r\n    onRequest?: (url: string, init: RequestInit) => Promise<Request>;\r\n    /**\r\n     * Callback invoked when a network or parsing error occurs during streaming.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param error The error that occurred.\r\n     */\r\n    onSseError?: (error: unknown) => void;\r\n    /**\r\n     * Callback invoked when an event is streamed from the server.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @param event Event streamed from the server.\r\n     * @returns Nothing (void).\r\n     */\r\n    onSseEvent?: (event: StreamEvent<TData>) => void;\r\n    serializedBody?: RequestInit['body'];\r\n    /**\r\n     * Default retry delay in milliseconds.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 3000\r\n     */\r\n    sseDefaultRetryDelay?: number;\r\n    /**\r\n     * Maximum number of retry attempts before giving up.\r\n     */\r\n    sseMaxRetryAttempts?: number;\r\n    /**\r\n     * Maximum retry delay in milliseconds.\r\n     *\r\n     * Applies only when exponential backoff is used.\r\n     *\r\n     * This option applies only if the endpoint returns a stream of events.\r\n     *\r\n     * @default 30000\r\n     */\r\n    sseMaxRetryDelay?: number;\r\n    /**\r\n     * Optional sleep function for retry backoff.\r\n     *\r\n     * Defaults to using `setTimeout`.\r\n     */\r\n    sseSleepFn?: (ms: number) => Promise<void>;\r\n    url: string;\r\n  };\r\n\r\nexport interface StreamEvent<TData = unknown> {\r\n  data: TData;\r\n  event?: string;\r\n  id?: string;\r\n  retry?: number;\r\n}\r\n\r\nexport type ServerSentEventsResult<\r\n  TData = unknown,\r\n  TReturn = void,\r\n  TNext = unknown,\r\n> = {\r\n  stream: AsyncGenerator<\r\n    TData extends Record<string, unknown> ? TData[keyof TData] : TData,\r\n    TReturn,\r\n    TNext\r\n  >;\r\n};\r\n\r\nexport const createSseClient = <TData = unknown>({\r\n  onRequest,\r\n  onSseError,\r\n  onSseEvent,\r\n  responseTransformer,\r\n  responseValidator,\r\n  sseDefaultRetryDelay,\r\n  sseMaxRetryAttempts,\r\n  sseMaxRetryDelay,\r\n  sseSleepFn,\r\n  url,\r\n  ...options\r\n}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {\r\n  let lastEventId: string | undefined;\r\n\r\n  const sleep =\r\n    sseSleepFn ??\r\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\r\n\r\n  const createStream = async function* () {\r\n    let retryDelay: number = sseDefaultRetryDelay ?? 3000;\r\n    let attempt = 0;\r\n    const signal = options.signal ?? new AbortController().signal;\r\n\r\n    while (true) {\r\n      if (signal.aborted) break;\r\n\r\n      attempt++;\r\n\r\n      const headers =\r\n        options.headers instanceof Headers\r\n          ? options.headers\r\n          : new Headers(options.headers as Record<string, string> | undefined);\r\n\r\n      if (lastEventId !== undefined) {\r\n        headers.set('Last-Event-ID', lastEventId);\r\n      }\r\n\r\n      try {\r\n        const requestInit: RequestInit = {\r\n          redirect: 'follow',\r\n          ...options,\r\n          body: options.serializedBody,\r\n          headers,\r\n          signal,\r\n        };\r\n        let request = new Request(url, requestInit);\r\n        if (onRequest) {\r\n          request = await onRequest(url, requestInit);\r\n        }\r\n        // fetch must be assigned here, otherwise it would throw the error:\r\n        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n        const _fetch = options.fetch ?? globalThis.fetch;\r\n        const response = await _fetch(request);\r\n\r\n        if (!response.ok)\r\n          throw new Error(\r\n            `SSE failed: ${response.status} ${response.statusText}`,\r\n          );\r\n\r\n        if (!response.body) throw new Error('No body in SSE response');\r\n\r\n        const reader = response.body\r\n          .pipeThrough(new TextDecoderStream())\r\n          .getReader();\r\n\r\n        let buffer = '';\r\n\r\n        const abortHandler = () => {\r\n          try {\r\n            reader.cancel();\r\n          } catch {\r\n            // noop\r\n          }\r\n        };\r\n\r\n        signal.addEventListener('abort', abortHandler);\r\n\r\n        try {\r\n          while (true) {\r\n            const { done, value } = await reader.read();\r\n            if (done) break;\r\n            buffer += value;\r\n\r\n            const chunks = buffer.split('\\n\\n');\r\n            buffer = chunks.pop() ?? '';\r\n\r\n            for (const chunk of chunks) {\r\n              const lines = chunk.split('\\n');\r\n              const dataLines: Array<string> = [];\r\n              let eventName: string | undefined;\r\n\r\n              for (const line of lines) {\r\n                if (line.startsWith('data:')) {\r\n                  dataLines.push(line.replace(/^data:\\s*/, ''));\r\n                } else if (line.startsWith('event:')) {\r\n                  eventName = line.replace(/^event:\\s*/, '');\r\n                } else if (line.startsWith('id:')) {\r\n                  lastEventId = line.replace(/^id:\\s*/, '');\r\n                } else if (line.startsWith('retry:')) {\r\n                  const parsed = Number.parseInt(\r\n                    line.replace(/^retry:\\s*/, ''),\r\n                    10,\r\n                  );\r\n                  if (!Number.isNaN(parsed)) {\r\n                    retryDelay = parsed;\r\n                  }\r\n                }\r\n              }\r\n\r\n              let data: unknown;\r\n              let parsedJson = false;\r\n\r\n              if (dataLines.length) {\r\n                const rawData = dataLines.join('\\n');\r\n                try {\r\n                  data = JSON.parse(rawData);\r\n                  parsedJson = true;\r\n                } catch {\r\n                  data = rawData;\r\n                }\r\n              }\r\n\r\n              if (parsedJson) {\r\n                if (responseValidator) {\r\n                  await responseValidator(data);\r\n                }\r\n\r\n                if (responseTransformer) {\r\n                  data = await responseTransformer(data);\r\n                }\r\n              }\r\n\r\n              onSseEvent?.({\r\n                data,\r\n                event: eventName,\r\n                id: lastEventId,\r\n                retry: retryDelay,\r\n              });\r\n\r\n              if (dataLines.length) {\r\n                yield data as any;\r\n              }\r\n            }\r\n          }\r\n        } finally {\r\n          signal.removeEventListener('abort', abortHandler);\r\n          reader.releaseLock();\r\n        }\r\n\r\n        break; // exit loop on normal completion\r\n      } catch (error) {\r\n        // connection failed or aborted; retry after delay\r\n        onSseError?.(error);\r\n\r\n        if (\r\n          sseMaxRetryAttempts !== undefined &&\r\n          attempt >= sseMaxRetryAttempts\r\n        ) {\r\n          break; // stop after firing error\r\n        }\r\n\r\n        // exponential backoff: double retry each attempt, cap at 30s\r\n        const backoff = Math.min(\r\n          retryDelay * 2 ** (attempt - 1),\r\n          sseMaxRetryDelay ?? 30000,\r\n        );\r\n        await sleep(backoff);\r\n      }\r\n    }\r\n  };\r\n\r\n  const stream = createStream();\r\n\r\n  return { stream };\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\ninterface SerializeOptions<T>\r\n  extends SerializePrimitiveOptions,\r\n    SerializerOptions<T> {}\r\n\r\ninterface SerializePrimitiveOptions {\r\n  allowReserved?: boolean;\r\n  name: string;\r\n}\r\n\r\nexport interface SerializerOptions<T> {\r\n  /**\r\n   * @default true\r\n   */\r\n  explode: boolean;\r\n  style: T;\r\n}\r\n\r\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\r\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\r\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\r\nexport type ObjectStyle = 'form' | 'deepObject';\r\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\r\n\r\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\r\n  value: string;\r\n}\r\n\r\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\r\n  switch (style) {\r\n    case 'label':\r\n      return '.';\r\n    case 'matrix':\r\n      return ';';\r\n    case 'simple':\r\n      return ',';\r\n    default:\r\n      return '&';\r\n  }\r\n};\r\n\r\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\r\n  switch (style) {\r\n    case 'form':\r\n      return ',';\r\n    case 'pipeDelimited':\r\n      return '|';\r\n    case 'spaceDelimited':\r\n      return '%20';\r\n    default:\r\n      return ',';\r\n  }\r\n};\r\n\r\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\r\n  switch (style) {\r\n    case 'label':\r\n      return '.';\r\n    case 'matrix':\r\n      return ';';\r\n    case 'simple':\r\n      return ',';\r\n    default:\r\n      return '&';\r\n  }\r\n};\r\n\r\nexport const serializeArrayParam = ({\r\n  allowReserved,\r\n  explode,\r\n  name,\r\n  style,\r\n  value,\r\n}: SerializeOptions<ArraySeparatorStyle> & {\r\n  value: unknown[];\r\n}) => {\r\n  if (!explode) {\r\n    const joinedValues = (\r\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\r\n    ).join(separatorArrayNoExplode(style));\r\n    switch (style) {\r\n      case 'label':\r\n        return `.${joinedValues}`;\r\n      case 'matrix':\r\n        return `;${name}=${joinedValues}`;\r\n      case 'simple':\r\n        return joinedValues;\r\n      default:\r\n        return `${name}=${joinedValues}`;\r\n    }\r\n  }\r\n\r\n  const separator = separatorArrayExplode(style);\r\n  const joinedValues = value\r\n    .map((v) => {\r\n      if (style === 'label' || style === 'simple') {\r\n        return allowReserved ? v : encodeURIComponent(v as string);\r\n      }\r\n\r\n      return serializePrimitiveParam({\r\n        allowReserved,\r\n        name,\r\n        value: v as string,\r\n      });\r\n    })\r\n    .join(separator);\r\n  return style === 'label' || style === 'matrix'\r\n    ? separator + joinedValues\r\n    : joinedValues;\r\n};\r\n\r\nexport const serializePrimitiveParam = ({\r\n  allowReserved,\r\n  name,\r\n  value,\r\n}: SerializePrimitiveParam) => {\r\n  if (value === undefined || value === null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof value === 'object') {\r\n    throw new Error(\r\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\r\n    );\r\n  }\r\n\r\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\r\n};\r\n\r\nexport const serializeObjectParam = ({\r\n  allowReserved,\r\n  explode,\r\n  name,\r\n  style,\r\n  value,\r\n  valueOnly,\r\n}: SerializeOptions<ObjectSeparatorStyle> & {\r\n  value: Record<string, unknown> | Date;\r\n  valueOnly?: boolean;\r\n}) => {\r\n  if (value instanceof Date) {\r\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\r\n  }\r\n\r\n  if (style !== 'deepObject' && !explode) {\r\n    let values: string[] = [];\r\n    Object.entries(value).forEach(([key, v]) => {\r\n      values = [\r\n        ...values,\r\n        key,\r\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\r\n      ];\r\n    });\r\n    const joinedValues = values.join(',');\r\n    switch (style) {\r\n      case 'form':\r\n        return `${name}=${joinedValues}`;\r\n      case 'label':\r\n        return `.${joinedValues}`;\r\n      case 'matrix':\r\n        return `;${name}=${joinedValues}`;\r\n      default:\r\n        return joinedValues;\r\n    }\r\n  }\r\n\r\n  const separator = separatorObjectExplode(style);\r\n  const joinedValues = Object.entries(value)\r\n    .map(([key, v]) =>\r\n      serializePrimitiveParam({\r\n        allowReserved,\r\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\r\n        value: v as string,\r\n      }),\r\n    )\r\n    .join(separator);\r\n  return style === 'label' || style === 'matrix'\r\n    ? separator + joinedValues\r\n    : joinedValues;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport type { BodySerializer, QuerySerializer } from './bodySerializer.gen';\r\nimport {\r\n  type ArraySeparatorStyle,\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from './pathSerializer.gen';\r\n\r\nexport interface PathSerializer {\r\n  path: Record<string, unknown>;\r\n  url: string;\r\n}\r\n\r\nexport const PATH_PARAM_RE = /\\{[^{}]+\\}/g;\r\n\r\nexport const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\r\n  let url = _url;\r\n  const matches = _url.match(PATH_PARAM_RE);\r\n  if (matches) {\r\n    for (const match of matches) {\r\n      let explode = false;\r\n      let name = match.substring(1, match.length - 1);\r\n      let style: ArraySeparatorStyle = 'simple';\r\n\r\n      if (name.endsWith('*')) {\r\n        explode = true;\r\n        name = name.substring(0, name.length - 1);\r\n      }\r\n\r\n      if (name.startsWith('.')) {\r\n        name = name.substring(1);\r\n        style = 'label';\r\n      } else if (name.startsWith(';')) {\r\n        name = name.substring(1);\r\n        style = 'matrix';\r\n      }\r\n\r\n      const value = path[name];\r\n\r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        url = url.replace(\r\n          match,\r\n          serializeArrayParam({ explode, name, style, value }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (typeof value === 'object') {\r\n        url = url.replace(\r\n          match,\r\n          serializeObjectParam({\r\n            explode,\r\n            name,\r\n            style,\r\n            value: value as Record<string, unknown>,\r\n            valueOnly: true,\r\n          }),\r\n        );\r\n        continue;\r\n      }\r\n\r\n      if (style === 'matrix') {\r\n        url = url.replace(\r\n          match,\r\n          `;${serializePrimitiveParam({\r\n            name,\r\n            value: value as string,\r\n          })}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const replaceValue = encodeURIComponent(\r\n        style === 'label' ? `.${value as string}` : (value as string),\r\n      );\r\n      url = url.replace(match, replaceValue);\r\n    }\r\n  }\r\n  return url;\r\n};\r\n\r\nexport const getUrl = ({\r\n  baseUrl,\r\n  path,\r\n  query,\r\n  querySerializer,\r\n  url: _url,\r\n}: {\r\n  baseUrl?: string;\r\n  path?: Record<string, unknown>;\r\n  query?: Record<string, unknown>;\r\n  querySerializer: QuerySerializer;\r\n  url: string;\r\n}) => {\r\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\r\n  let url = (baseUrl ?? '') + pathUrl;\r\n  if (path) {\r\n    url = defaultPathSerializer({ path, url });\r\n  }\r\n  let search = query ? querySerializer(query) : '';\r\n  if (search.startsWith('?')) {\r\n    search = search.substring(1);\r\n  }\r\n  if (search) {\r\n    url += `?${search}`;\r\n  }\r\n  return url;\r\n};\r\n\r\nexport function getValidRequestBody(options: {\r\n  body?: unknown;\r\n  bodySerializer?: BodySerializer | null;\r\n  serializedBody?: unknown;\r\n}) {\r\n  const hasBody = options.body !== undefined;\r\n  const isSerializedBody = hasBody && options.bodySerializer;\r\n\r\n  if (isSerializedBody) {\r\n    if ('serializedBody' in options) {\r\n      const hasSerializedBody =\r\n        options.serializedBody !== undefined && options.serializedBody !== '';\r\n\r\n      return hasSerializedBody ? options.serializedBody : null;\r\n    }\r\n\r\n    // not all clients implement a serializedBody property (i.e. client-axios)\r\n    return options.body !== '' ? options.body : null;\r\n  }\r\n\r\n  // plain/text body\r\n  if (hasBody) {\r\n    return options.body;\r\n  }\r\n\r\n  // no body was provided\r\n  return undefined;\r\n}\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nexport type AuthToken = string | undefined;\r\n\r\nexport interface Auth {\r\n  /**\r\n   * Which part of the request do we use to send the auth?\r\n   *\r\n   * @default 'header'\r\n   */\r\n  in?: 'header' | 'query' | 'cookie';\r\n  /**\r\n   * Header or query parameter name.\r\n   *\r\n   * @default 'Authorization'\r\n   */\r\n  name?: string;\r\n  scheme?: 'basic' | 'bearer';\r\n  type: 'apiKey' | 'http';\r\n}\r\n\r\nexport const getAuthToken = async (\r\n  auth: Auth,\r\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\r\n): Promise<string | undefined> => {\r\n  const token =\r\n    typeof callback === 'function' ? await callback(auth) : callback;\r\n\r\n  if (!token) {\r\n    return;\r\n  }\r\n\r\n  if (auth.scheme === 'bearer') {\r\n    return `Bearer ${token}`;\r\n  }\r\n\r\n  if (auth.scheme === 'basic') {\r\n    return `Basic ${btoa(token)}`;\r\n  }\r\n\r\n  return token;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { getAuthToken } from '../core/auth.gen';\r\nimport type { QuerySerializerOptions } from '../core/bodySerializer.gen';\r\nimport { jsonBodySerializer } from '../core/bodySerializer.gen';\r\nimport {\r\n  serializeArrayParam,\r\n  serializeObjectParam,\r\n  serializePrimitiveParam,\r\n} from '../core/pathSerializer.gen';\r\nimport { getUrl } from '../core/utils.gen';\r\nimport type { Client, ClientOptions, Config, RequestOptions } from './types.gen';\r\n\r\nexport const createQuerySerializer = <T = unknown>({\r\n  allowReserved,\r\n  array,\r\n  object,\r\n}: QuerySerializerOptions = {}) => {\r\n  const querySerializer = (queryParams: T) => {\r\n    const search: string[] = [];\r\n    if (queryParams && typeof queryParams === 'object') {\r\n      for (const name in queryParams) {\r\n        const value = queryParams[name];\r\n\r\n        if (value === undefined || value === null) {\r\n          continue;\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          const serializedArray = serializeArrayParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'form',\r\n            value,\r\n            ...array,\r\n          });\r\n          if (serializedArray) search.push(serializedArray);\r\n        } else if (typeof value === 'object') {\r\n          const serializedObject = serializeObjectParam({\r\n            allowReserved,\r\n            explode: true,\r\n            name,\r\n            style: 'deepObject',\r\n            value: value as Record<string, unknown>,\r\n            ...object,\r\n          });\r\n          if (serializedObject) search.push(serializedObject);\r\n        } else {\r\n          const serializedPrimitive = serializePrimitiveParam({\r\n            allowReserved,\r\n            name,\r\n            value: value as string,\r\n          });\r\n          if (serializedPrimitive) search.push(serializedPrimitive);\r\n        }\r\n      }\r\n    }\r\n    return search.join('&');\r\n  };\r\n  return querySerializer;\r\n};\r\n\r\n/**\r\n * Infers parseAs value from provided Content-Type header.\r\n */\r\nexport const getParseAs = (\r\n  contentType: string | null,\r\n): Exclude<Config['parseAs'], 'auto'> => {\r\n  if (!contentType) {\r\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\r\n    // which is effectively the same as the 'stream' option.\r\n    return 'stream';\r\n  }\r\n\r\n  const cleanContent = contentType.split(';')[0]?.trim();\r\n\r\n  if (!cleanContent) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    cleanContent.startsWith('application/json') ||\r\n    cleanContent.endsWith('+json')\r\n  ) {\r\n    return 'json';\r\n  }\r\n\r\n  if (cleanContent === 'multipart/form-data') {\r\n    return 'formData';\r\n  }\r\n\r\n  if (\r\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\r\n      cleanContent.startsWith(type),\r\n    )\r\n  ) {\r\n    return 'blob';\r\n  }\r\n\r\n  if (cleanContent.startsWith('text/')) {\r\n    return 'text';\r\n  }\r\n\r\n  return;\r\n};\r\n\r\nconst checkForExistence = (\r\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  },\r\n  name?: string,\r\n): boolean => {\r\n  if (!name) {\r\n    return false;\r\n  }\r\n  if (\r\n    options.headers.has(name) ||\r\n    options.query?.[name] ||\r\n    options.headers.get('Cookie')?.includes(`${name}=`)\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const setAuthParams = async ({\r\n  security,\r\n  ...options\r\n}: Pick<Required<RequestOptions>, 'security'> &\r\n  Pick<RequestOptions, 'auth' | 'query'> & {\r\n    headers: Headers;\r\n  }) => {\r\n  for (const auth of security) {\r\n    if (checkForExistence(options, auth.name)) {\r\n      continue;\r\n    }\r\n\r\n    const token = await getAuthToken(auth, options.auth);\r\n\r\n    if (!token) {\r\n      continue;\r\n    }\r\n\r\n    const name = auth.name ?? 'Authorization';\r\n\r\n    switch (auth.in) {\r\n      case 'query':\r\n        if (!options.query) {\r\n          options.query = {};\r\n        }\r\n        options.query[name] = token;\r\n        break;\r\n      case 'cookie':\r\n        options.headers.append('Cookie', `${name}=${token}`);\r\n        break;\r\n      case 'header':\r\n      default:\r\n        options.headers.set(name, token);\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nexport const buildUrl: Client['buildUrl'] = (options) =>\r\n  getUrl({\r\n    baseUrl: options.baseUrl as string,\r\n    path: options.path,\r\n    query: options.query,\r\n    querySerializer:\r\n      typeof options.querySerializer === 'function'\r\n        ? options.querySerializer\r\n        : createQuerySerializer(options.querySerializer),\r\n    url: options.url,\r\n  });\r\n\r\nexport const mergeConfigs = (a: Config, b: Config): Config => {\r\n  const config = { ...a, ...b };\r\n  if (config.baseUrl?.endsWith('/')) {\r\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\r\n  }\r\n  config.headers = mergeHeaders(a.headers, b.headers);\r\n  return config;\r\n};\r\n\r\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\r\n  const entries: Array<[string, string]> = [];\r\n  headers.forEach((value, key) => {\r\n    entries.push([key, value]);\r\n  });\r\n  return entries;\r\n};\r\n\r\nexport const mergeHeaders = (\r\n  ...headers: Array<Required<Config>['headers'] | undefined>\r\n): Headers => {\r\n  const mergedHeaders = new Headers();\r\n  for (const header of headers) {\r\n    if (!header) {\r\n      continue;\r\n    }\r\n\r\n    const iterator =\r\n      header instanceof Headers\r\n        ? headersEntries(header)\r\n        : Object.entries(header);\r\n\r\n    for (const [key, value] of iterator) {\r\n      if (value === null) {\r\n        mergedHeaders.delete(key);\r\n      } else if (Array.isArray(value)) {\r\n        for (const v of value) {\r\n          mergedHeaders.append(key, v as string);\r\n        }\r\n      } else if (value !== undefined) {\r\n        // assume object headers are meant to be JSON stringified, i.e. their\r\n        // content value in OpenAPI specification is 'application/json'\r\n        mergedHeaders.set(\r\n          key,\r\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return mergedHeaders;\r\n};\r\n\r\ntype ErrInterceptor<Err, Res, Req, Options> = (\r\n  error: Err,\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Err | Promise<Err>;\r\n\r\ntype ReqInterceptor<Req, Options> = (\r\n  request: Req,\r\n  options: Options,\r\n) => Req | Promise<Req>;\r\n\r\ntype ResInterceptor<Res, Req, Options> = (\r\n  response: Res,\r\n  request: Req,\r\n  options: Options,\r\n) => Res | Promise<Res>;\r\n\r\nclass Interceptors<Interceptor> {\r\n  fns: Array<Interceptor | null> = [];\r\n\r\n  clear(): void {\r\n    this.fns = [];\r\n  }\r\n\r\n  eject(id: number | Interceptor): void {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = null;\r\n    }\r\n  }\r\n\r\n  exists(id: number | Interceptor): boolean {\r\n    const index = this.getInterceptorIndex(id);\r\n    return Boolean(this.fns[index]);\r\n  }\r\n\r\n  getInterceptorIndex(id: number | Interceptor): number {\r\n    if (typeof id === 'number') {\r\n      return this.fns[id] ? id : -1;\r\n    }\r\n    return this.fns.indexOf(id);\r\n  }\r\n\r\n  update(\r\n    id: number | Interceptor,\r\n    fn: Interceptor,\r\n  ): number | Interceptor | false {\r\n    const index = this.getInterceptorIndex(id);\r\n    if (this.fns[index]) {\r\n      this.fns[index] = fn;\r\n      return id;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  use(fn: Interceptor): number {\r\n    this.fns.push(fn);\r\n    return this.fns.length - 1;\r\n  }\r\n}\r\n\r\nexport interface Middleware<Req, Res, Err, Options> {\r\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\r\n  request: Interceptors<ReqInterceptor<Req, Options>>;\r\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\r\n}\r\n\r\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\r\n  Req,\r\n  Res,\r\n  Err,\r\n  Options\r\n> => ({\r\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\r\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\r\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\r\n});\r\n\r\nconst defaultQuerySerializer = createQuerySerializer({\r\n  allowReserved: false,\r\n  array: {\r\n    explode: true,\r\n    style: 'form',\r\n  },\r\n  object: {\r\n    explode: true,\r\n    style: 'deepObject',\r\n  },\r\n});\r\n\r\nconst defaultHeaders = {\r\n  'Content-Type': 'application/json',\r\n};\r\n\r\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\r\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\r\n): Config<Omit<ClientOptions, keyof T> & T> => ({\r\n  ...jsonBodySerializer,\r\n  headers: defaultHeaders,\r\n  parseAs: 'auto',\r\n  querySerializer: defaultQuerySerializer,\r\n  ...override,\r\n});\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { createSseClient } from '../core/serverSentEvents.gen';\r\nimport type { HttpMethod } from '../core/types.gen';\r\nimport { getValidRequestBody } from '../core/utils.gen';\r\nimport type {\r\n  Client,\r\n  Config,\r\n  RequestOptions,\r\n  ResolvedRequestOptions,\r\n} from './types.gen';\r\nimport {\r\n  buildUrl,\r\n  createConfig,\r\n  createInterceptors,\r\n  getParseAs,\r\n  mergeConfigs,\r\n  mergeHeaders,\r\n  setAuthParams,\r\n} from './utils.gen';\r\n\r\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\r\n  body?: any;\r\n  headers: ReturnType<typeof mergeHeaders>;\r\n};\r\n\r\nexport const createClient = (config: Config = {}): Client => {\r\n  let _config = mergeConfigs(createConfig(), config);\r\n\r\n  const getConfig = (): Config => ({ ..._config });\r\n\r\n  const setConfig = (config: Config): Config => {\r\n    _config = mergeConfigs(_config, config);\r\n    return getConfig();\r\n  };\r\n\r\n  const interceptors = createInterceptors<\r\n    Request,\r\n    Response,\r\n    unknown,\r\n    ResolvedRequestOptions\r\n  >();\r\n\r\n  const beforeRequest = async (options: RequestOptions) => {\r\n    const opts = {\r\n      ..._config,\r\n      ...options,\r\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\r\n      headers: mergeHeaders(_config.headers, options.headers),\r\n      serializedBody: undefined,\r\n    };\r\n\r\n    if (opts.security) {\r\n      await setAuthParams({\r\n        ...opts,\r\n        security: opts.security,\r\n      });\r\n    }\r\n\r\n    if (opts.requestValidator) {\r\n      await opts.requestValidator(opts);\r\n    }\r\n\r\n    if (opts.body !== undefined && opts.bodySerializer) {\r\n      opts.serializedBody = opts.bodySerializer(opts.body);\r\n    }\r\n\r\n    // remove Content-Type header if body is empty to avoid sending invalid requests\r\n    if (opts.body === undefined || opts.serializedBody === '') {\r\n      opts.headers.delete('Content-Type');\r\n    }\r\n\r\n    const url = buildUrl(opts);\r\n\r\n    return { opts, url };\r\n  };\r\n\r\n  const request: Client['request'] = async (options) => {\r\n    // @ts-expect-error\r\n    const { opts, url } = await beforeRequest(options);\r\n    const requestInit: ReqInit = {\r\n      redirect: 'follow',\r\n      ...opts,\r\n      body: getValidRequestBody(opts),\r\n    };\r\n\r\n    let request = new Request(url, requestInit);\r\n\r\n    for (const fn of interceptors.request.fns) {\r\n      if (fn) {\r\n        request = await fn(request, opts);\r\n      }\r\n    }\r\n\r\n    // fetch must be assigned here, otherwise it would throw the error:\r\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\r\n    const _fetch = opts.fetch!;\r\n    let response = await _fetch(request);\r\n\r\n    for (const fn of interceptors.response.fns) {\r\n      if (fn) {\r\n        response = await fn(response, request, opts);\r\n      }\r\n    }\r\n\r\n    const result = {\r\n      request,\r\n      response,\r\n    };\r\n\r\n    if (response.ok) {\r\n      const parseAs =\r\n        (opts.parseAs === 'auto'\r\n          ? getParseAs(response.headers.get('Content-Type'))\r\n          : opts.parseAs) ?? 'json';\r\n\r\n      if (\r\n        response.status === 204 ||\r\n        response.headers.get('Content-Length') === '0'\r\n      ) {\r\n        let emptyData: any;\r\n        switch (parseAs) {\r\n          case 'arrayBuffer':\r\n          case 'blob':\r\n          case 'text':\r\n            emptyData = await response[parseAs]();\r\n            break;\r\n          case 'formData':\r\n            emptyData = new FormData();\r\n            break;\r\n          case 'stream':\r\n            emptyData = response.body;\r\n            break;\r\n          case 'json':\r\n          default:\r\n            emptyData = {};\r\n            break;\r\n        }\r\n        return opts.responseStyle === 'data'\r\n          ? emptyData\r\n          : {\r\n              data: emptyData,\r\n              ...result,\r\n            };\r\n      }\r\n\r\n      let data: any;\r\n      switch (parseAs) {\r\n        case 'arrayBuffer':\r\n        case 'blob':\r\n        case 'formData':\r\n        case 'json':\r\n        case 'text':\r\n          data = await response[parseAs]();\r\n          break;\r\n        case 'stream':\r\n          return opts.responseStyle === 'data'\r\n            ? response.body\r\n            : {\r\n                data: response.body,\r\n                ...result,\r\n              };\r\n      }\r\n\r\n      if (parseAs === 'json') {\r\n        if (opts.responseValidator) {\r\n          await opts.responseValidator(data);\r\n        }\r\n\r\n        if (opts.responseTransformer) {\r\n          data = await opts.responseTransformer(data);\r\n        }\r\n      }\r\n\r\n      return opts.responseStyle === 'data'\r\n        ? data\r\n        : {\r\n            data,\r\n            ...result,\r\n          };\r\n    }\r\n\r\n    const textError = await response.text();\r\n    let jsonError: unknown;\r\n\r\n    try {\r\n      jsonError = JSON.parse(textError);\r\n    } catch {\r\n      // noop\r\n    }\r\n\r\n    const error = jsonError ?? textError;\r\n    let finalError = error;\r\n\r\n    for (const fn of interceptors.error.fns) {\r\n      if (fn) {\r\n        finalError = (await fn(error, response, request, opts)) as string;\r\n      }\r\n    }\r\n\r\n    finalError = finalError || ({} as string);\r\n\r\n    if (opts.throwOnError) {\r\n      throw finalError;\r\n    }\r\n\r\n    // TODO: we probably want to return error and improve types\r\n    return opts.responseStyle === 'data'\r\n      ? undefined\r\n      : {\r\n          error: finalError,\r\n          ...result,\r\n        };\r\n  };\r\n\r\n  const makeMethodFn =\r\n    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>\r\n      request({ ...options, method });\r\n\r\n  const makeSseFn =\r\n    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {\r\n      const { opts, url } = await beforeRequest(options);\r\n      return createSseClient({\r\n        ...opts,\r\n        body: opts.body as BodyInit | null | undefined,\r\n        headers: opts.headers as unknown as Record<string, string>,\r\n        method,\r\n        onRequest: async (url, init) => {\r\n          let request = new Request(url, init);\r\n          for (const fn of interceptors.request.fns) {\r\n            if (fn) {\r\n              request = await fn(request, opts);\r\n            }\r\n          }\r\n          return request;\r\n        },\r\n        url,\r\n      });\r\n    };\r\n\r\n  return {\r\n    buildUrl,\r\n    connect: makeMethodFn('CONNECT'),\r\n    delete: makeMethodFn('DELETE'),\r\n    get: makeMethodFn('GET'),\r\n    getConfig,\r\n    head: makeMethodFn('HEAD'),\r\n    interceptors,\r\n    options: makeMethodFn('OPTIONS'),\r\n    patch: makeMethodFn('PATCH'),\r\n    post: makeMethodFn('POST'),\r\n    put: makeMethodFn('PUT'),\r\n    request,\r\n    setConfig,\r\n    sse: {\r\n      connect: makeSseFn('CONNECT'),\r\n      delete: makeSseFn('DELETE'),\r\n      get: makeSseFn('GET'),\r\n      head: makeSseFn('HEAD'),\r\n      options: makeSseFn('OPTIONS'),\r\n      patch: makeSseFn('PATCH'),\r\n      post: makeSseFn('POST'),\r\n      put: makeSseFn('PUT'),\r\n      trace: makeSseFn('TRACE'),\r\n    },\r\n    trace: makeMethodFn('TRACE'),\r\n  } as Client;\r\n};\r\n","// This file is auto-generated by @hey-api/openapi-ts\r\n\r\nimport { type ClientOptions, type Config, createClient, createConfig } from './client';\r\nimport type { ClientOptions as ClientOptions2 } from './types.gen';\r\n\r\n/**\r\n * The `createClientConfig()` function will be called on client initialization\r\n * and the returned object will become the client's initial configuration.\r\n *\r\n * You may want to initialize your client this way instead of calling\r\n * `setConfig()`. This is useful for example if you're using Next.js\r\n * to ensure your client always has the correct values.\r\n */\r\nexport type CreateClientConfig<T extends ClientOptions = ClientOptions2> = (override?: Config<ClientOptions & T>) => Config<Required<ClientOptions> & T>;\r\n\r\nexport const client = createClient(createConfig<ClientOptions2>({\r\n    baseUrl: 'https://localhost:44365'\r\n}));\r\n"],"names":["jsonBodySerializer","body","_key","value","createSseClient","onRequest","onSseError","onSseEvent","responseTransformer","responseValidator","sseDefaultRetryDelay","sseMaxRetryAttempts","sseMaxRetryDelay","sseSleepFn","url","options","lastEventId","sleep","ms","resolve","retryDelay","attempt","signal","headers","requestInit","request","response","reader","buffer","abortHandler","done","chunks","chunk","lines","dataLines","eventName","line","parsed","data","parsedJson","rawData","error","backoff","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","valueOnly","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","matches","match","replaceValue","getUrl","baseUrl","query","querySerializer","pathUrl","search","getValidRequestBody","hasBody","getAuthToken","auth","callback","token","createQuerySerializer","array","object","queryParams","serializedArray","serializedObject","serializedPrimitive","getParseAs","contentType","_a","cleanContent","type","checkForExistence","_b","setAuthParams","security","buildUrl","mergeConfigs","a","b","config","mergeHeaders","headersEntries","entries","mergedHeaders","header","iterator","Interceptors","id","index","fn","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","createClient","_config","getConfig","setConfig","interceptors","beforeRequest","opts","_fetch","result","parseAs","emptyData","textError","jsonError","finalError","makeMethodFn","method","makeSseFn","init","client"],"mappings":"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"}